title:: 五谈ai软件栈--无责乱弹ai软件栈研发方法论 (highlights)
author:: [[NVIDIA CUTLASS]]
full-title:: "五谈ai软件栈--无责乱弹ai软件栈研发方法论"
category:: #articles
url:: https://zhuanlan.zhihu.com/p/547878945

- Highlights first synced by [[Readwise]] [[Feb 5th, 2023]]
	- “没有历史包袱”这个观点也很值得商榷。因为哪怕是一家start-up新做的硬件，也难免带有了过往核心团队的技术legacy，这种legacy对技术路线的影响往往还比较深远，技术演进从来都不是完全割裂的。 ([View Highlight](https://instapaper.com/read/1575973302/21858188))
	- 一套AI软件栈，最重要的是解决哪些问题？（这里我又引入了一个假设，即驱动这一层已经不存在本质问题，因为驱动这一层工作不是我的专长，另外根据个人一些有限的经历，我会认为对于AI软件栈来说，驱动往往在硬件bring-up早期会是blocking issue，但很快就会让位于其他主要矛盾，所以引入这个假设存在合理性）我认为是三个：
	  
	  硬件算子库的开发。
	  AI框架的对接策略。
	  端到端快速集成链路的搭建。 ([View Highlight](https://instapaper.com/read/1575973302/21858192))
	- 算子库要解决的问题是什么，我试着以自己的理解，将其描述为，给定<算子类型, 问题尺寸, 计算精度, 数据排布方式, 关联Fusion Pattern>这样一个五元组输入，获得一个或多个高质量计算kernel（这里暂时不讨论通信kernel的问题，虽然二者在普遍义上是相通的）的问题。
	  
	  这里衡量kernel质量的判定因素有几个：
	  
	  功能正确性。
	  性能。
	  Binary size。
	  研发效率。
	  性能可测性。 ([View Highlight](https://instapaper.com/read/1575973302/21858197))
	- 长久以来，关于算子库研发一直会有手写 v.s. 自动codegen的两种作法。站在底层原理的角度，这两种作法实际上存在着很强的联系及互补性，而非互斥性。具体体现在
	  
	  手写计算库的粒度控制得当，实际上可以作为"软件抽象层ISA"的形态被codegen路径来进行装配调用。
	  自动codegen技术路径里的一些作法，比如autotune，以及对计算访存指令穿插次序的自动选取枚举策略等，可以直接应用于手写环节来辅助提升手写计算kernel效率。
	  新硬件，新优化策略的优化，往往是先以手写方式展开，以减少任何先验框架带来的灵活性约束，方法论成形以后，则可能以合适的方式进行抽象提炼，供更具生产研发效率的手写或codegen方式来调用了。 ([View Highlight](https://instapaper.com/read/1575973302/21858213))
	- 推理场景。以compiler-based的方式为主。原因比较简单，推理场景获得全局计算图虽然也可能跌跌撞撞，但我的判断要比训练场景的代价小得多。解决了前端问题，compiler-based的方式就更可能派上用场了。 ([View Highlight](https://instapaper.com/read/1575973302/21858222))
	- 不论是训练还是推理场景，在设计伊始都需要提供便于客户支持及业务前端团队根据业务需求进行快速定制的口子，缩短业务需求的反馈周期。具体来说，单设备上要建立起快捷的新定制算子暴露出到训练和推理框架的路径，并且要考虑到新定制算子在不经过正式框架发布情况下也能够参与到全局性质优化动作，避免成为全局优化的“孤岛”。分布式，要为手工定制策略及runtime提供足够的灵活性。这其实也是另一个值得延展开的topic了。 ([View Highlight](https://instapaper.com/read/1575973302/21858224))
	- 设立专属的架构师团队。这个团队不需要负责具体的产品研发，其核心职责在于基于这个集成链路进行训练或推理workload的持续分析，提供全链路优化的建议给到各个功能开发团队。这个团队的成员构成，需要足够hands-on，最好有过直接地参与各个功能开发的经验。同时要给他们足够的空间，在不需要承担具体功能开发的前提下，也能建立起对其工作成果认可的反馈链路。 ([View Highlight](https://instapaper.com/read/1575973302/21858228))
	- 软件栈各个层次模块均可以由各功能模团队DIY式地完成全栈系统的构建运行及测试，这个构建可以基于各模块的master版本，也可以是基于特定的release版本。模块与模块之间有着清晰的contract，描述对不同版本支持兼容性。这个构建，运行及测试的过程能够在一天内完成。凡是导致不能在一天内完成的问题都视为第一优先级，投入资源来解决，可能是对构建系统本身的优化（有不少公司对自己的代码管理工具和构建系统做过复杂的优化以满足自身需求，比如Google），也可能是对某模块的修改重构，使得其符合这个E2E构建的要求。 ([View Highlight](https://instapaper.com/read/1575973302/21858230))
	- 上述两个安排相辅相成，前者偏流程，后者偏人治，这里的考虑是，AI软件栈全链路系统过于复杂，其细节层面复杂性已经逼近或超越了个体能直接把握的复杂性边界，即便有了一个以天单位可以DIY完成构建运行测试的全栈build的infra支持，也可能因为缺失了一些背景信息，导致对集成链路中可能出现的问题出现错判，漏判，误判。这种情况下，引入一个相对“超然”，能够从具体功能开发事务中解放出来，又具备足够hands-on能力的架构师团队，就可以进行软性的补位（假设研发资源无限^-^）。 ([View Highlight](https://instapaper.com/read/1575973302/21858231))